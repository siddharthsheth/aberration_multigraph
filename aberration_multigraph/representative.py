"""
Representative graph construction for aberration multigraphs (AMGs).

This module builds a *representative graph* whose vertices correspond to
aberration multigraphs (AMGs) with a fixed chromosome count and DSB distribution.
Two AMGs are adjacent if they differ by a single elementary combinatorial
operation:

- **Total twists**: reversing all rejoinings along a single chromosome.
- **Total swaps**: exchanging the rejoin configurations of two chromosomes
  with identical DSB counts.

The resulting representative graph encodes the structure of the space of AMGs
under these operations and is useful for studying equivalence classes,
connectivity, and symmetry.

Due to the cost of AMG generation, this module is intended for small instances.
"""

from aberration_multigraph.generator import AMGGenerator
from matplotlib import pyplot as plt
import matplotlib as mpl
import networkx as nx

class AMGRepresentative():
    """
    Construct and analyze the representative graph of aberration multigraphs.

    Each node in the representative graph represents a distinct AMG (identified
    by its rejoin-edge configuration). An edge between two nodes indicates that
    one AMG can be obtained from the other by a single total twist or total swap.
    """

    def __init__(self, num_chromosomes, num_dsbs):
        """
        Initialize a representative-graph builder.

        Parameters
        ----------
        num_chromosomes : int
            Number of chromosomes.
        num_dsbs : iterable of int
            Number of DSBs on each chromosome, ordered by chromosome index.
        """
        self.num_chromosomes = num_chromosomes
        self.num_dsbs = num_dsbs

        self.generator = AMGGenerator(num_chromosomes, num_dsbs)

        # Maps rejoin-edge sets to canonical AMG identifiers
        self.rejoin_name_map = {}

        # Adjacency list: AMG name -> set of (neighbor_name, operation_index)
        self.adjacency_list = {}

        # Representative graph (constructed later)
        self.rep_graph = None

    def compute_amg_adjacency_list(self):
        """
        Compute adjacency information between AMGs under allowed operations.

        For each AMG generated by the underlying ``AMGGenerator``:
        - Apply all valid total twists (one per chromosome).
        - Apply all valid total swaps between chromosomes with equal
          numbers of DSBs.

        Each resulting AMG is identified by its rejoin-edge set, and adjacency
        information is recorded symbolically without constructing the full
        representative graph.

        Side Effects
        ------------
        Populates:
        - ``self.rejoin_name_map``
        - ``self.adjacency_list``
        """
        self.adjacency_list = {}
        self.rejoin_name_map = {}
        for amg in self.generator.generate_amgs():
            # self.rejoin_name_map[(amg.dsbs,amg.rejoins)] = amg.name
            self.rejoin_name_map[amg.rejoins] = amg.name
            for k in range(self.num_chromosomes):
                chrom_nodes = set(i for i in amg.graph.nodes if amg.graph.nodes[i]['chromosome'] == k)
                start, stop = min(chrom_nodes), max(chrom_nodes)
                if amg in self.adjacency_list:
                    self.adjacency_list[amg].add((amg._rejoin_edges_total_twist(start, stop), k+1))
                else:
                    self.adjacency_list[amg] = {(amg._rejoin_edges_total_twist(start, stop), k+1)}

            operation_number = self.num_chromosomes+1
            for i in range(self.num_chromosomes):
                for j in range(i, self.num_chromosomes):
                    chrom_1, chrom_2 = (j, i) if j < i else (i, j)
                    chrom_1_nodes = set(k for k in amg.graph.nodes if amg.graph.nodes[k]['chromosome'] == chrom_1)
                    chrom_2_nodes = set(k for k in amg.graph.nodes if amg.graph.nodes[k]['chromosome'] == chrom_2)
                    if len(chrom_1_nodes) == len(chrom_2_nodes):
                        start_1, stop_1 = min(chrom_1_nodes), max(chrom_1_nodes)
                        start_2, stop_2 = min(chrom_2_nodes), max(chrom_2_nodes)
                        # self.adjacency_list[amg].add((amg.dsbs_total_swap(start_1,start_2,stop_1,stop_2), amg.rejoin_edges_total_swap(start_1,start_2,stop_1,stop_2), operation_number))
                        self.adjacency_list[amg].add((amg._rejoin_edges_total_swap(start_1,start_2,stop_1,stop_2), operation_number))
                        operation_number += 1
    
    def compute_representative_graph(self):
        """
        Build the representative graph from the computed adjacency list.

        Returns
        -------
        networkx.Graph
            The representative graph. Nodes correspond to AMG identifiers;
            edges indicate a single total twist or total swap.

        Notes
        -----
        ``compute_amg_adjacency_list'' must be called before this method.
        """
        if not self.adjacency_list:
            raise RuntimeError(
                'Adjacency list is empty. Call compute_amg_adjacency_list() first.'
            )
        self.rep_graph = nx.Graph()
        for amg in self.adjacency_list:
            for nbr_rejoin_edge, operation in self.adjacency_list[amg]:
                nbr = self.rejoin_name_map[nbr_rejoin_edge]
                if nbr != amg.name:
                    self.rep_graph.add_edge(amg.name, nbr, color=operation)

    def draw_representative_graph(self):
        """
        Visualize the representative graph using a spring layout.

        Edge colors correspond to the operation indices used to transform one
        AMG into another. This method is intended for exploratory visualization;
        readability may degrade for large graphs.
        """
        if self.rep_graph is None:
            raise RuntimeError(
                'Representative graph not built. Call compute_representative_graph() first.'
            )
        
        pos = nx.spring_layout(self.rep_graph)
        cmap = mpl.colormaps['tab20']
        # color_palette = [i for i in range(self.num_operations)]
        colors = [cmap(self.rep_graph[u][v]['color']) for u,v in self.rep_graph.edges]
        nx.draw_networkx_nodes(self.rep_graph, pos, node_color = 'white', node_size=50)
        nx.draw_networkx_labels(self.rep_graph, pos, font_size=8)
        nx.draw_networkx_edges(self.rep_graph, pos, width=1, edgelist=self.rep_graph.edges, edge_color=colors)

if __name__ == '__main__':
    amg_rep = AMGRepresentative(2, (2,2,1))
    amg_rep.compute_amg_adjacency_list()
    # print(amg_rep.adjacency_list)
    # print(amg_rep.rejoin_name_map)
    amg_rep.compute_representative_graph()
    amg_rep.draw_representative_graph()
    # nx.draw(amg_rep.rep_graph)
    # print(len(amg_rep.groups))
    # for graph in amg_rep.groups.keys():
    #     plt.figure()
    #     i = 1
    #     for amg in amg_rep.groups[graph]:
    #         plt.subplot(4,2,i)
    #         amg.draw()
    #         i += 1
    plt.show()
